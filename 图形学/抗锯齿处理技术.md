#抗锯齿处理技术
##锯齿产生的原因
![](https://learnopengl-cn.github.io/img/04/11/anti_aliasing_rasterization_filled.png)
光栅化的时候，是以像素中心点是否被三角形覆盖来决定是否产生片段，因此有些片段覆盖了采样点就生成，有些没有覆盖就不生成，最终产生了锯齿现象。
##超采样抗锯齿(SSAA)
产生锯齿的主要原因是由于采样频率过低导致的，为了消除锯齿，所以引入了SSAA，其主要思想就是提高采样频率，把一个像素均等分成四份，变成4个子样本，就相当于原本一个像素只采样一次，现在采样四次，采样了直接提高四倍。
![](https://pic3.zhimg.com/80/v2-cce9b8b9bb42822abac7f646ee9d63e6_720w.jpg)
![](https://pic2.zhimg.com/80/v2-af8cf51159af3af95cd95867412f40d9_720w.jpg)
针对每一个子采样点，重复母像素的流程，判定是否在三角形内、深度检测，着色，最后每个子采样点都会得到各自的颜色，母像素的颜色就是子采样点颜色的平均。
* 开销
  1. 原始的算法会为像素点维护一个depth_buffer和color-buffer，n个像素点就分别对应n大小的数组，使用SSAA后，子采样点的深度和颜色也需要维护，所以depth-buffer和color-buffer的数组就扩充为2*2*n
  2. SSAA的计算复杂度也会增大，判定是在三角形内。深度检测，计算着色的操作也会增多。
##多重采样抗锯齿(MSAA)
基本概念
在光栅化阶段，判断三角形是否被像素覆盖是，会计算多个采样点，然后计算一个覆盖率；在片段着色阶段，每个像素仍然只计算一次颜色值，片段以像素中央来进行计算，只是最后的结果会乘上一个覆盖率；MSAA的高效性在于，他没有每个采样点都计算一次着色，而是每个像素只计算一次着色，然后乘上一个覆盖率。

##快速近似抗锯齿(FXAA)
FXAA（Fast Approximate Anti-Aliasing），快速近似抗锯齿处理，是MSAA一种高性能近似；它位于后处理阶段实现，不依赖于硬件；总体思想是：a. 找出图像中的所有边缘（通过亮度比较，G分量）；b.平滑化边缘（沿着某个方向将一定范围的像素取出来加权平均）。
##深度学习超采样(DLSS)

DLSS 2.0可以在不损失画质的情况下，通过人工智能 /深度学习，直接把游戏实时渲染的结果实现四倍超采样。

#阴影技术
对于静态的物体，可以使用LightMap烘焙的方法来获取物体的影子；对于动态的物体，一般采用的是Shadownmap技术
##光照贴图(lightMap)
1. 原理：从光源的方向去烘焙(离线渲染)一个物体，把结果存在一张贴图里，因为离线渲染的时候，如果光线和物体之间有东西遮挡，那么物体上该点就会存在阴影，那么在LightMap上就是一个阴影的值(较暗的像素)，然后渲染的时候直接对该物体从光照贴图里面采样即可。
2. 缺点：Lightmap只能存diffuse分量，不能存specular分量，没办法做动态阴影；

##阴影贴图(Shadowmap)
1. 原理
   是一种渲染到纹理的技术，首先是从光源的位置渲染一遍场景，将得到的深度信息写入到贴图中，然后再一次正常的渲染场景，利用我们得到的shadowmap来判断哪些片段落在了阴影中


#延迟渲染和正向渲染
##正向渲染
它是我们渲染物体的一种非常直接的方式，在场景中根据所有光源照亮物体，然后再渲染下一个物体，它对程序性能的影响也很大，因为对于每一个需要渲染的物体，程序都要对每一个光源每一个渲染的片段进行迭代，并且大部分片段着色器的输出都会被之后的输出覆盖，正向渲染还会在场景中因为高深的复杂度浪费大量的片段着色器运行时间。
##延迟渲染
延迟渲染首先将物体的结合信息(位置，法线，颜色，镜面值)存到几何缓冲区中(G_Buffer),然后再光照处理阶段，使用GBuffer中的纹理数据，对每个片段进行光照；这种渲染方法一个很大的好处就是能保证在G-buffer中的片段和在屏幕上呈现的像素所包含的片段信息是一样的，因为深度测试已经最终将这里的片段信息作为最顶层的片段。这样保证了对于在光照处理阶段的每一个像素只处理一次。
##区别，优缺点

延迟渲染的优点：将光源的数目和场景中物体的数目在复杂度层次上完全分开，只渲染最上面一层可见的像素，节省计算量；
延迟渲染的缺点：
1. 内存开销大，读写G-buffer的内存带宽量时性能瓶颈
2. 对透明物品的渲染存在问题(不支持混色）
3. 对多重采样抗锯齿(MSAA)处理的支持不太好。



