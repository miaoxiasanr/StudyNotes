# 多线程
c++11提供了语言层义上的多线程。包含在头文件 < thread>。他解决了跨平台的问题，提供了管理线程、保护共享数据、线程间同步操作、原子操作等。C++11新标准引入了5个头文件支持多线程编程，如图所示：
![](https://img-blog.csdnimg.cn/20210428113430200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1FMZWVscQ==,size_16,color_FFFFFF,t_70#pic_center)
## 多进程和多线程
* 多进程并发
  使用多进程并发是将一个应用程序划分为多个独立的进程(每个进程只有一个线程)，这些独立的进程间可以互相通信，共同完成任务。由于操作系统对进程听了大量的保护机制，以避免一个进程修改了另一个进程的数据，使用多进程比多线程更容易写出安全的代码。
  > 多进程的缺点
  > 1. 在进程间的通信，无论是使用信号，套接字，文件还是管道等方式，使用时要么就是比较复杂，要么就是速度较慢或者两者都有。
  > 2. 运行多个进程的开销很大，操作系统要分配很多的资源来对这些进程进行管理。
* 多线程并发
  多线程并发是指在同一个进程中执行多个线程。
  * 优点
    线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说：同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样同一进程内的多个进程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。
  * 缺点
    由于缺少系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多工作以保证共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁。

## 多线程理解
* 单CPU内核的多个线程
  一个时间片运行一个线程的代码，并不是真正意义上的并行计算。
  ![](https://img-blog.csdnimg.cn/20210416084451659.png)
* 多个CPU或者对个内核
  真正的并行计算
  ![](https://img-blog.csdnimg.cn/2021041608452349.png)


## 创建线程
创建线程只需把函数添加到线程当中即可

* 形式1
  ~~~c++
    std::thread Testthread(thread_fun);//函数形式类似于 void thread_fun();
    Testthread.join();
  ~~~
* 形式2
    ~~~c++
    std::thread Testthread(thread_fun(100));//函数形式类似于 void thread_fun(int x);
    Testthread.join();
    ~~~
* 形式3
  ~~~c++
    std::thread(thread_fun,1).detach();//直接创建线程，没有名字；函数形式类似于 void thread_fun(int x);
  ~~~

### join()和detach()的区别
当线程启动时，一定要在线程相关联的thread销毁前，确定以何种方式等待线程结束。
* join方式：等待启动的线程完成，才会继续往下执行。
* detach方式：启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束。

> 可以使用joinable判断是否可以成功使用join()或者detach()
> ~~~c++
> thread TestThread(func);
> if(TestThread.joinable())
> {
>       TestThread.join();
>        //TestThread.detach();
> }
> ~~~

### this_thread
this_thread是一个类，它有4个功能函数：
|函数|使用|说明|
|-|-|-|
|get_id|std::this_thread::get_id()|获取线程id|
|yield|std::this_thread::yield()|放弃线程执行，回到就绪状态|
|sleep_for|std::this_thread::sleep_for(std::chrono::seconds(1))|暂停1s|
|sleep_until|如下|一分钟后执行|
~~~c++
using std::chrono::system_clock
std::time_t tt=ststem_clock::to_time_t(system_cloack::now());
struct std::tm *ptm=std::localtime(&tt);
++ptm->tm_min;
ptm->tm_sec=0;
this_thread::sleep_until(system_clock::formtime_t(mktime(ptm)));
~~~
