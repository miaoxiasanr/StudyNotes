#计算机网络
##网络协议层次
![](https://pic.leetcode-cn.com/1612150605-NindRH-image.png)
###OSI参考模型
1. 应用层
   应用层位于OSI参考模型的第七层，起作用是通过应用程序间的交互来完成特定的网络应用。该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统DNS，支持万维网应用的HTTP协议，电子邮件系统采用的SMTP协议等，在应用层交互的数据单元称之为报文。
2. 表示层
   表示层的作用是使通信的应用程序能够解释交换数据的含义。向上为应用层提供服务，向下接受来自会话层的服务。该层提供的服务主要包括数据压缩，数据加密和数据描述，这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。
3. 会话层
   会话层就是负责建立。管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法
4. 传输层
   主要任务是为两台主机进程之间的通信提供服务。应用程序利用该服务传送应用层报文。该服务并不针对某一特定的应用，多种应用可以使用同一个传输层服务。
5. 网络层
   两台计算机之间传输数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网
   网络层的只要人物就是选择合适的网路间路由和交换节点，确保数据按时传送
   在发送数据时，网络层吧传输层产生的报文或者用户数据封装成分组和包向下传输到数据链路层
   在网络层使用的协议是无连接的网络协议和许多路由协议，所以又称为IP层
6. 数据链路层
   两台主机之间的数据传输，总是在一段一段的链路上传送的，需要专门的链路层协议。
   在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻节点之间传送数据。

7. 物理层
   实现计算机节点之间比特流的透明传输，尽可能的屏蔽掉具体传输介质和物理设备的差异。
###TCP/IP参考模型
1. 应用层
   TCP/IP模型将OSI模型中的会话层、表示层和应用层的功能合并到一个应用层上面，通过不同的应用层协议为不同的应用提供服务。例如FTP、telnet、DNS、SMTP等
2. 传输层
   该层对应于OSI参考模型传输层，为上层实体提供源端到对端主机的通信功能。
   主要定义了两个和主要协议：
        1. TCP协议
        2. UDP协议
3. 网际互联层
   对应OSI的网络层，只要负责相同或不同网络中计算机之间的通信，
   在互联层，IP协议提供的是一个不可靠、无连接的数据报传递服务，该协议实现两个基本功能：寻址和分段
   根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中IP负者选择传送线路；
4. 网络接入层
   对应物理层和数据链路报，他负责监视数据在主机和网络之间的交换。
   事实上TCP/IP并未真正描述这一层的实现，而是由互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。

###OSI模型和TCP/IP模型异同比较
![](https://www.runoob.com/wp-content/uploads/2018/09/1538030296-8668-20150904095142060-1017190812.gif)
相同点
   1. OSI参考模型与TCP/IP参考模型都采用了层次模型
   2. 能够提供面向连接和无连接两种通信服务机制
不同点
   1. OSI采用七层模型；TCP/IP是四层结构
   2. TCP/IP参考模型没有对网络接口进行细分，只是一些概念性的描述；OSI参考模型对服务和协议做了明确的区分
   3. OSI是先有模型后有协议范围，适用于描述各种网络；TCP/IP是先有协议后建立模型，不适用于非TCP/IP网络
   4. TCP/IP一开始就提出面向连接和无连接服务；而OSI一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准
   5. OSI参考模型虽然被看好，但将网络划分成七层，实现起来较为困难。；相反，TCP/IP参考模型虽然有很多不尽人意的地方，但作为一种叫简化的分层结构还是比较成功的；
##应用层
1. Keep-Alive和非Keep-Alive区别？
   ![](https://pic.leetcode-cn.com/1612195694-ROTKiX-%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5.png)
   非Keep-Alive:必须为每一个请求的对象建立和维护一个全新的连接，对于这样一个连接，客户端好服务端都要分配TCP的缓冲区和变量，这个服务器带来了严重的负担，一台服务器不能同时服务于数以百计的客户端需求；
    Keep-Alive：服务器在响应后保持该TCP连接打开，在同一个客户端和服务端之间的后续请求好响应报文可通过相同的连接进行传送。
2. HTTP和HTTPs的工作方式（建立连接的过程）及其区别？
   * HTTP
     1. 默认使用TCP协议的80端口，通信内容明文传输
   * HTTPS
      1. 请求：433端口，建立TCP连接
     1. 客户端发送支持的对称加密算法列表和秘钥长度
     2. 服务器根据双方共同支持的加密算法列表选择一种返回给客户端
     3. 服务器返回自身的CA证书，证书包括可服务器域名和公钥
     4. 客户端用本地证书库的根证书校验CA证书，生成随机密码串作为后续对称加密的种子，用公钥加密发送给服务器
     5. 服务器用私钥解密报文，得到随机密码串，用协商好的对称加密算法好种子，加密数据报文发送给客户端
     6. SSL连接建立
    * 区别：
       1. HTTP已明文方式发送，数据都是未加密的，安全性较差；HTTPs数据传输加密，安全性好
       2. HTTP和HTTPS使用的是完全不同的连接方式，用的端口不一样，前者是80端口，后者是443端口
       3. HTTPS协议需要数字机构申请证书，需要一定费用
       4. HTTP响应比HTTPS块，主要是HTTP使用三次握手建立连接，客户端和服务器需要握手3次，而HTTPS除了TCp的3次握手，还需要经历一个SSL协商过程。
3. 网页解析全过程
   ![](https://pic.leetcode-cn.com/1612459029-slhrTZ-%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%9B%BE.png)
   1. DNS解析：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个IP地址，因此我们需要先把域名转化成相应的IP地址
   2. TCP连接：浏览器通过DNS获取到web服务器真正的IP地址后，便向web服务器发起了TCP请求，通过三次握手建立好连接之后，浏览器便可以向HTTP请求数据发送给服务器了。
   3. 发送HTTP请求：浏览器向web服务器发起了一个HTTP请求，HTTP协议是建立在TCP协议之上的应用层协议，其本质是在建立起的TCP连接中，按照HTTP协议标椎发送一个索要网页的请求
   4. 处理请求并返回:服务器获取到客户端的HTTP请求后，会根据HTTP请求中的内容来决定如何获取响应的文件，并将文件发送给浏览器；
   5. 浏览器渲染：浏览器根据响应显示页面，首先解析HTML文件构建DOM树，完后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器就将其绘制到屏幕上
   6. 断开连接：客户端和服务器通过四次挥手终止TCP连接。
4. DNS
   DNS是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，由于TCP/IP网络
   DNS的作用：
        进行主机名到IP地址转换的目录服务，域名系统作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。
5. 状态码
   |状态码|中文描述|
   |-|-|
   |100|继续，客户端继续处理请求|
   |200|请求成功|
   |403|拒绝访问|
   |404|找不到资源|
   |500|服务器错误|  
##传输层
###三次握手
![](https://pic.leetcode-cn.com/1614160878-FiFlkq-image.png)
三次握手是TCP连接的建立过程。在握手之前，主动打开连接的客户端结束CLOSE阶段，被动打开的服务器也结束CLOSE阶段，并进入LISTEN阶段。随后进入三次握手阶段；
1. 首先客户端向服务器发送一个SYN包，并等待服务端确认，其中：
   * 标志位为SYN，表示请求建立连接
   * 序号为Seq=x(x一般为随机数)
   * 随后客户端进入SYN_SEND阶段
2. 服务器接收来自客户端发来的SYN包之后，对该包进行确认后结束LISTEN阶段，并返回一段TCP报文，其中：
   * 标志位为SYN+ACK，表示明确客户端的报文Seq序号有序，服务器能正常接收客户端发送的数据，并同意创建新连接
   * 序号Seq=y；
   * 确认号Ack=x+1;表示收到客户端的序号Seq并将其值加1作为自己确认号ACK的值，随后客户端进入SYN_RECV阶段
3. 客户端接受来自服务器发送的SYN+ACK包后，明确了从客户端到服务器的数据传输是正常的，从而结束SYN-SENT阶段。并返回最后一段报文。其中：
    * 标志位为ACK，闹事明确收到服务器端同意连接的信号
    * 序号Seq=x+1；表示收到服务器的确认号Ack，并将其值作为自己的序号值；
    * 确认号为Ack=y+1，表示受到服务端序号Seq。并将其值加1作为自己确认号的值
    * 随后客户端进入ESTABLISHED阶段；
###四次挥手
![](https://pic.leetcode-cn.com/1612459478-ajInIu-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)
四次挥手即TCP连接的释放，这里假设客户端释放连接。在挥手之前主动释放连接的客户端结束ESHABLISHED阶段，随后开始四次挥手：
1. 首先客户端向服务器发送一段TCP报文表明想要释放TCP连接，其中：
   * 标记位为FIN。表示请求释放连接
   * 序号Seq=u；
   * 随后客户端进入FIN-WAIT-1阶段，即半关闭阶段，并且停止向服务端发送通信数据。
2. 服务器接收到客户端请求断开连接的FIn报文后，结束ESHABLISHED阶段，进入CLOSE_WAIT阶段并返回一段TCP报文，其中：
   * 标记位为ACK，表明接收到客户端释放连接的请求；
   * 序号为Seq=v；
   * 确认号Ack=u+1，表示是在受到客户端报文的基础上，将其序号值加1作为本段报文确认号Ack的值
   * 随后服务器开始准备释放服务端到客户端方向上的连接。
客户端收到服务端发送过来的TCP报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端结束FIN—WAIT—1阶段，进入FIN-WAIT-2阶段
3. 服务端在发出ACK确认报文后，服务端会将一流的待传送数据传送给客户端，带传输完成之后即经过CLOSE-WAIT阶段，便做好了释放服务端到客户端的连接准备，再次向客户端发送一段TCP报文，其中：
   * 标记位为FIN+ACK，表示已经准备好释放连接了；
   * 序号Seq=w;
   * 确认号Ack=u+1;表示在收到客户端报文的基础上，将其序号seq的值加1作为本段报文确认号Ack的值
随后服务端结束CLOSE_WAIT阶段，进入LAST_ACK阶段，并且停止向客户端发送数据
4. 客户端收到从服务端发来的TCP报文，确认了服务器已经做好释放连接的准备，于是结束FIN_WAIT_2阶段，进入TIME_WAIT阶段。并向服务端发送一段报文，其中：
   * 标记位为ACK，表示接受到服务端准备好释放连接的信号；
   * 序号Seq=u+1；表示是在收到服务端报文的基础上，将其确认号Ack的值作为本段序号的值；
   * 确认号Ack=w+1;表示是在收到了服务端报文的基础上，将其序号Seq的值作为本段报文确认号的值
随后客户端在TIME_WAIT阶段等待2MSL。服务器端接收到从客户端发出的TCP报文后结束LAST_ACK阶段，进入CLOSED阶段，由此正式确认关闭服务器到客户端方向上的连接。客户端等待完2MSL后，结束TIME_WAIT阶段，进入CLOSE阶段
###三次握手&&四次挥手的一些问题
1. 三次握手的作用？
   1. 第一次握手
   服务器未收到客户端请求建立连接的数据报是，服务器不会有任何相应的动作，而客户端由于在一段时间内没有收到服务器发来的确认报文，因此等待一段时间后重新发送SYN同步报文。若仍然没有得到回应，重复上述过程；在超过最大次数限制后，建立连接的系统会返回-1；
   2. 第二次握手
   客户端未收到服务器回应的ACK报文时，客户端会采取第一次握手失败时的动作，而服务器此时将阻塞在accept()系统调用出等待client再次发送ACK报文
   3. 第三次握手
   服务器未收到客户端发送过来的ACk报文，同样会采取类似于客户端的超时重传机制，若重传次数超过限制仍没有得到回应，则服务端建立连接失败，但客户端认为建立连接成功，隐藏开始向服务端发送数据，但是服务端没有连接成功，不在监听状态，因此服务器接受来自接户端发送过来的数据时会发送RST报文给客户端，消除客户端单方面的连接。
2. 为什么要进行三次握手？两次行吗？
   三次握手的目的：主要是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信，若采取两次握手，当第二次握手就建立连接的画，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器不能知道客户端能否接收到自己发送的数据。
   第一次握手：服务端确认客户端的发送正常
   第二次握手：客户端确认服务端的收发正常
   第三次握手：服务端确认客户端的接受正常
   如果只有前两次握手，服务端发个客户端的包丢了以后，服务端就直接建立了连接，然后一直傻等不会释放，造成阻塞。
3. 四次挥手的意义
   是因为FIN释放连接报文金额ACK确认接受报文时分贝在两次握手中传输的。当主动方在数据传输结束后法术释放连接的通知，由于被动方可能还有必要的数据要处理，所以会先返回ACK确认报文，但被动方没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。
4. CLOSE_WAIT和TIME_WAIT的意义
   在服务器接收到客户单发来关闭连接的请求后，服务器进入CLOSE_WAIT阶段，然而此时服务器还有一些数据没有传输完成，因此不能关闭，CLOSE_WAIT状态是为了保证服务器在关闭连接之前将待发送的数据发送完成。
   TIME_WAIT是在第四次挥手后，客户端进入的状态，时候客户端必要的等待时间。等待的目的是：服务端的对应端口关闭与客户端发送到服务端的数据到达，如果不存在这个步骤就会导致两个问题：
        1. 客户端立即关闭后，又立即用同样的端口握手并建立通信，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常发生
        2. 客户端直接关闭后，客户端最后一次发送的ACK包在传输的时候丢失了，若服务端重新发送FIN包，客户端就会回应RST，这使得对方认为有错误发生，然而其实是正常的关闭连接过程，并没有出现异常情况。
5. TIME_WAIT为什么是2MSL；
   MSL:指一段TCP报文在传输过程中的最大生命周期
   2MSL：是服务器发出FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长；
   如果服务器在1MSL后任然没有收到客户端发送的ACk确认报文，那么他会向客户单重传FIN报文，对客户端而言，从客户端发起ACK报文起，重传的FIN报文的最晚达到时间是2MSL；
###TCP&&UDP
1. 区别
   |类型|是否面向连接|传输可靠性|传输形式|传输效率|所需资源|应用场景|
   |-|-|-|-|-|-|-|
   |TCP|是|可靠|字节流|慢|多|文件传输，邮件传输|
   |UDP|否|不可靠|数据报传输|快|少|即时通讯|


2. UDP不可靠的原因
   1. UDP只有一个SOCKET接收缓冲区，没有发送缓冲区，只要有数据就发，不管对方是否可以正常接收
   2. 在对方的socket接收缓冲区满了以后，新来的数据报无法进入到socket接收缓冲区，此数据包就会被丢弃，UDP不能保证数据能够到达目的地。
3. TCP如何保证可靠性
   1. 数据分块：应用数据被分成TCP认为最合适发送的数据块
   2. 序列号和确认应答：TCP给发送的每一个包进行编号，传输过程中，每次接受方接受数据后，都会对传输方发送报文
   3. 校验和：如果接收到报文段的检验和有差错，将丢弃这个报文段并且不确认收到此报文
   4. 流量控制：TCP连接双方都有一个固定的缓冲空间，发送的数据不能超过接收方缓冲区的大小，TCP通过滑动窗口来支持流量控制机制
   5. 拥塞控制：但网络某个节点发生拥塞时，减少数据发送
   6. ARQ协议：每发完一个分组就停止发送，等待对方确认，收到确认后再发下一个分组
   7. 超时重传：TCP发出一个报文段后，会启动一个定时器，如果超过某个时间还没有得到恢复，就会进行重新发送这个报文段。
4. TCP流量控制和拥塞阻塞
   流量控制：
   所谓流量控制就是不要让发送方发送的太快，让接收方来得及接收
   如果接收方来不及接收发送方发送的数据，就会有分组流失
   主要方式是接收方返回的ACK中国会包含自己的接收窗口的大小，TCP利用可变长的滑动窗口机制控制发送方发送的数据大小
   拥塞阻塞
   除了发送方和接收方之外，还有路由器。交换机等复杂的网络传输路线1，这就需要拥塞控制
   拥塞控制是作用于网络，防止过多的数据注入到网络中，避免出现网络负载过大的情况
##网络层
###IP
IP协议又称互联网协议，是支持网间互联的数据包协议
该协议工作在网络层，主要目的是为了提高网络的可扩展性，和传输层TCP相比，IP协议提供了一种无连接/不可靠、尽力而为的数据包传输服务，
作用：
1. 寻址和路由
   在IP数据包中会携带源IP地址和目的IP地址来标识该数据包的源主机和目的主机
2. 分段和重组
   IP数据包在传输过程中可能会经过不同的网络，在不同的网络中数据包的最大长度限制是不同的，IP协议通过给每个IP数据包分配一个标识符以及分段与组装的相关信息，在到达目的主机后由目的主机完成重组工作，恢复出原来的IP数据包。
###其他问题
1. 路由器和交换机的区别
   路由器：
   路由器听过数据包中的目的IP地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的。
   路由器根据选择协议和路由表数据确定数据的转发路径，直到到达目的网络，工作于网络层
2. 交换机
   交换机用于局域网，利用主机的物理地址(MAC地址)确定数据转发的目的地址，工作于数据链路层
##数据链路层
1. MAC地址和IP地址的区别
   MAC地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址，MAC地址用来定义网络设备的位置。
   IP地址是网络层和以上各层使用的地址，是一种逻辑地址，IP地址用来区分网络上的计算机。
2. 为什么有了MAC地址还要有IP地址
   光有AMC地址的话寻址困难，IP地址和地域有关，可以分区域，效率更高
3. 为什么有了IP地址还要有MAC地址
   接入子网之后才会有IP地址，没接入之前用MAC地址区分
##物理层
1. 通信方式
   1. 单工通信
   发送方和接收方都是固定的，消息只能单向传递(打印机)
   2. 半双工通信
   双向交替通信，通信双方都能发送信息，但同一时刻同一信道只允许单方面发送数据(对讲机)
   3. 双工通信
   双向同时通信，允许通信双方同时在两个方向上传输，要求通信双方都具有独立的发送和接受数据的能力(打电话)