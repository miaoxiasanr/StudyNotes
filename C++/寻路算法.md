- [Dijkstra(迪杰斯特拉)算法](#dijkstra迪杰斯特拉算法)
  - [基本思想](#基本思想)
  - [示例](#示例)
- [A\*算法](#a算法)
  - [前置知识](#前置知识)
  - [启发函数](#启发函数)
- [navmesh寻路](#navmesh寻路)
  - [Recast 将场景网格模型生成寻路的导航网格](#recast-将场景网格模型生成寻路的导航网格)


# Dijkstra(迪杰斯特拉)算法
典型的最短路径的算法，用来求得起始点到其他所有点的最短路径，采用贪心的思想，每次查找与该点距离最近的点。
解决的问题可以描述为：在无向图G=(V,E)中，假设每条边E[i]的长度为W[i]，找到由顶点vs到其余各点的最短路径
## 基本思想
通过Dijkstra计算G中的最短路径时，需要指定起点vs，此外，需要引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U是记录还未求出最短路径的顶点(以及该顶点到起点vs的距离)，初始时，S中只有起点vs，而U中是除vs之外的顶点，并且U中顶点的路径时“起点vs到该顶点的路径”。然后 从U中找出路径最短的顶点，并将其加入到S中；接着更新U中的顶点和顶点对应的路径，重复该操作，直到遍历完所有顶点。
## 示例
![](https://pic002.cnblogs.com/images/2012/426620/2012073019593375.jpg)
|步骤|S集合中|U集合中|
|-|-|-|
|1|选入A,此时S={A}，最短路径A->A=0；以A为中间点开始找；|U={B,C,D,E,F},A->B=6,A->C=3,A->其他点为无穷，发现A->C=3权值为最短|
|2|选入C。此时S={A,C}，此时最短路径A->A=0，A->C=3,以C为中间点，从A->C=3这条路径开始找|U={B,D,E,F}，A->C->B=5(b比A->B=6要短)，此时更新B权值为A->C->B=5；A->C->D=6,A->C->E=7,A->C->其他点=无穷，发现A->C->B=5权值最短。|
|3|选入B，此时S={A,C,B}，此时最短路径A->A=0,A->C=3,A->C->B=5；以B为中间点，从A->C->b这条最短路径开始找|U={D,E,F}，A->C->B->D=10；(比上面第二步的A->C->D=6要长)此时到D的权值更改为A->C->D=6；A->C->B-》其他点=无穷，发现A->C->D权值最短；|
|4|选入D。此时S={A,B,C,D}，此时最短路径A->A=0,A->C=3,A->C->B=5,A->C->D=6；以D为中间点，从A->C->D这条路径开始找|此时U={E,F}，A->C->D->E=8(比上面第二步的A->C->E=7要长)此时到E的权值更改为A->C->E=7；A->C->D->F=9；发现A->C->E=7权值为最短；|
|5|选入E，此时S={A,C,B,D,E}，此时最短路径A->A=0,A->C=3,A->C->B=5,A->C->D=6，A->C->E=7这条路径最短，以E为中心点最短路径开始找|U={F}，A->C->E->F=12（比上面第四步的A->C->D->F=9要长）此时F权值更改为A->C->D->F=9|
|6|选入F，此时S={A,C,B,D,E}，此时最短路径A->A=0,A->C=3,A->C->B=5,A->C->D=6，A->C->E=7，A->C->D->F=9最短|U集合空，查找完毕|

# A*算法
## 前置知识
1. 搜索区域：图中的搜索区域被划分为了简单的二维数组，数组每个元素对应一个小方格，通常将一个单位的中心点称之为搜索区域节点。
2. 开放列表：我们将路径规划过程中待检测的节点存放于OpenList中，而已检测的格子则存放于CloseList中。
3. 父节点：在路径规划中用于回溯的节点，开发时可考虑为双向链表结构中的父节点指针
4. 路径排序：具体往哪个节点移动由以下公式决定：F(n)=G+H；G代表的是从初始位置A沿着已生成的路径到指定待检测格子的移动开销。H指待检测格子到目标点B的估计移动开销；
5. 启发函数：H为启发函数，也被认为是一种试探，由于在找到唯一路径前，我们不确定前面会出现什么障碍物，因此用了一种计算H的方法：传统的曼哈顿距离
    * 曼哈顿距离：两点在南北方向上的距离加上东西方向上的距离，即D=|x1-x2|+|y1-y2|
    * 对角距离  d=$\sqrt{2} \quad * 边长$
    * 欧式距离：d=$\sqrt{(x1-x2)^2+(y1-y2)^2)} \quad$


A*算法通过下面这个函数来计算每个节点的优先级
$$f(n)=g(n)+h(n)$$
其中：
* f(n)是节点n的综合优先级。当我们选择下一个要遍历的节点时，我们总要选取综合优先级最高(值最小)的节点。
* g(n)是节点n距离起点的代价
* h(n)是节点n距离终点的预计代价，这也算是A*算法的启发函数.
  
A*算法在运算过程中，每次从优先队列中选取f(n)值最小(优先级最高)的节点作为下一个待遍历的节点。另外，A *算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，通常被称为open_list和close_list

完整A*算法如下

~~~c++
初始化open_list和close_list;
将起点加入open_list中，并设置优先级为0(优先级最高)
如果open_list不为空，则从open_list中选取优先级最高的节点n;
  如果节点为终点，则：
      从终点开始逐步追踪parent节点，一直到达起点
      返回找到的结果路径，算法结束。
  如果节点n不是终点，则：
      将节点从open_list中删除，并加入close_list中；
      遍历节点n所有的邻近节点；
          如果邻近节点m在close_list中，则：
              跳过，选取下一个邻近节点；
          如果邻近节点在Open_list中，则：
              比较f(n)是否比原来更小，如果更小则更新其父节点
          如果邻近节点也不在open_list中，则：
              设置节点m的parent为节点n
              计算节点m的优先级
              将节点m加入open_list中；
~~~

## 启发函数
启发函数会影响A*算法的行为
* 在极端情况下，当启发函数h(n)始终为0，则将由g(n)决定节点的优先级，此时算法就退化成Dijkstra算法
* 如果h(n)始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当h(n)的值越小，算法将遍历越多的节点，也就导致算法越慢

对于网格形式的图，有以下这些启发函数可以使用
* 如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离
* 如果图形中允许朝八个方向移动，则可以使用对角距离
* 如果图形中允许朝任意方向移动，则可以使用欧几里得距离

[A*寻路算法](https://www.cnblogs.com/shiroe/p/15516246.html)


# navmesh寻路
## Recast 将场景网格模型生成寻路的导航网格
Recast：可以将地形数据进行抽象和简化，生成人工智能体可理解的导航数据
生成NavMesh数据主要两种方式:多边形裁剪和体素化
* 多边形裁剪是直接对地形的多边形网格数据进行裁剪及合并，从而生成导航网格。方法比较直观但难度更高
* 体素化是对地形多边形网格进行栅格化，然后用这些"格子"重新生成导航网格，方法更复杂，但难度更低，Recast使用了此方案，而UE4使用了Recast


优势：
* 自动化，可以处理任意地形数据，输出导航网格
* 快速高效
* 能处理动态碰撞
* 开源，可根据自己游戏内容定制
* 自带可视化工具

步骤
1. 创建体素模型：通过吧输入的三角形mesh进行光栅化，形成一个多层的高度场，就能得到体素模型。之后可以对体素模型做一些简单的过滤，去掉玩家不可达的位置
2. 将模型分割成简单的区域：体素模型描述的可行走区域划分成重叠的2D区域，这些区域只有一个未重叠的等高线，这可以大大简化最后一步处理步骤
3. 将这些区域分割成简单多边形：首先沿着边界划分这些区域并进行化简可以剥离出导航多边形，然后把这些导航多边形处理为凸多边形。
##Detour 利用导航网格进行寻路
