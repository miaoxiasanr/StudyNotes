#C++基础知识
##虚函数
###多态
   1. 什么是多态
        所谓多态，就是同一名字的事物可以完成不同的功能，例如有几个相似而不完全相同的事物，有时人们要求他们发出同一消息时，他们的反应各不相同，分别执行不同的操作。在C++中，所谓多态性是指继承而产生的相关的不同的类，其对象对同一消息会作出不同的响应。多态性是面向对象程序设计的一个重要特征，能有效增加程序的灵活性。
   2. C++的多态是如何实现的
        C++的多态分为编译时多态和运行时多态
        * 编译时多态也称静态联编，通过重载和模板来实现
        * 运行时多态也称动态联编，通过继承和虚函数来实现
### 虚函数的实现机制
   虚函数是通过虚函数表和虚函数表指针来实现的，虚函数表包含了一个类所有的虚函数的地址，当有虚函数的类对象中，它内存空间的头部会有一个虚函数表指针(虚表指针)，用来管理虚函数表。当子类对象对父类虚函数进行重写的时候，虚函数表的相应虚函数地址会发生改变，改写成这个虚函数的地址，当我们用一个父类的指针来操作子类对象的时候，它可以指明实际调用的函数

   虚函数表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。需要注意的是：普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。虚函数表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是在代码的编辑阶段，虚表就可以构造出来了

   * 一般继承
   ![](https://img2018.cnblogs.com/blog/1600805/201905/1600805-20190525232658903-633694331.png)
   ![](https://img2018.cnblogs.com/blog/1600805/201905/1600805-20190525232658388-60615093.png)
  *  如果派生类未覆盖基类虚函数：
      1. 虚函数按照其声明顺序放于表中，
      2. 父类的虚函数在子类的虚函数前面
   *  如果派生类覆盖基类虚函数：
      1. 虚表中派生类覆盖虚函数的地址被放在基类相应的函数原来的位置
      2. 派生类没有覆盖的虚函数沿用基类的

   * **多重继承**
   ![](https://img2018.cnblogs.com/blog/1600805/201905/1600805-20190526142349597-2051742718.png)
   * 如果派生类中无虚函数覆盖
      1. 每个基类都有自己的虚表
      2. 派生类的虚函数地址依照声明顺序放在第一个基类的虚表后边。
   * 如果派生类覆盖基类虚函数
      1. 虚表中派生类覆盖的虚函数的地址被放在基类相应的函数原来的位置
      2. 派生类没有覆盖的虚函数沿用基类的
###虚函数的作用
   允许我们在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数

### 纯虚函数
   当基类中不能为虚函数提供一个有意义的实现时，可以将其声明为纯虚函数，其实现在派生类中完成
   纯虚函数的作用是为派生类提供一个一致的接口，
   纯虚函数不能被实例化，但可以声明指针。
   ~~~c++
   virtual void TestFun()=0;
   ~~~
### 虚继承
   虚继承的出现是为了解决菱形继承的问题；
   * 菱形继承
    ![](https://segmentfault.com/img/bVbLkja)
        ~~~c++
        class A
        {
        public:
            int value;
        }
        class B:public A
        {}
        class C:public A
        {}
        class D:public B,public C
        {}

        int main
        {
            D d;
            cout<<d.value<<endl;//error 不明确的访问
            cout<<d.A::value<<endl;//正确
            cout<<d.B::value<<endl;//正确
            cout<<d.C::value<<endl;//正确
        }
        ~~~
        菱形继承出现的问题：
            1. 从同一途径继承来的同一基类，会在子类中进行多分拷贝浪费储存空间
            2. 存在二义性问题。
    * 虚继承
        ![](https://segmentfault.com/img/bVbLkji)
        ~~~c++
        class A
        {
        public:
            int value;
        }
        class B:virtual public A
        {}
        class C:virtual public A
        {}
        class D:public B,public C
        {}
        int main()
        {
            D d;
            cout<<d.value<<endl;//正确
        }
        ~~~
        虚继承的调用顺序
        每次我们创建D的时候先创建基类A的成员，然后通过虚基类指针和虚基表找到虚基类B中的地址创建它特有的成员，然后再找到C的地址创建它特有的成员，这样就不会将A的成员重复创建，实现了虚继承。
     
### 一些问题
1. 虚函数表建立的时间，虚指针建立时间，虚函数绑定时间？
   虚函数表是在编译阶段建立的，编译期间编译器就为每个类确定好了对应的虚函数表里内容；
   虚指针是跟着对象走的，对象什么时候创建，虚函数指针就什么时候创建出来，创建出来后，编译器就把虚表的首地址赋值给虚函数表指针，
   虚函数在运行期间绑定虚指针，通过查找虚函数表中的函数地址确定的
2. 调用普通函数比调用虚函数效率高的原因？
   普通函数静态绑定的，直接call就行了
   虚函数是动态绑定的，需要去对象的首地址，解引用到虚表的首地址，在加上偏移量找到虚函数，在通过call调用；

3. 虚函数是存在类中还是存在类对象中(是否共享虚表)？
   存在类中，同一类的不同对象共享一张虚表(为了节省空间)
4. 子类中既有继承也有复合，构造函数和析构函数调用顺序
   构造函数：先调父类的构造函数，再调复合的子类的构造函数，再调子类的构造函数
   析构函数：先析构子类的析构函数，在调用复合的析构函数，再调用父类的析构函数
5. 基类的析构函数可以调用虚函数吗?基类的构造函数可以调用虚函数吗？
   两者都不能
   构造函数
   虚函数在构造函数中不起作用。在构造基类的时候，派生类还没有完全创建，虽然有虚函数表，但是没有虚指针，不能访问对象的内存，也不能访问到虚表。
    析构函数
    析构函数和构造函数的调用顺序是相反的，当执行到基类的析构函数时，派生类的析构函数已经执行过了，派生类的数据被执行已经无效，所以不能调用；
6. 基类的构造函数可以是虚函数吗？基类的析构函数可以是虚函数吗？
   基类的构造函数一定不能声明成虚函数
   虚函数的作用是通过父类指针指向子类的成员函数，而构造函数是在创建对象的时候调用的，此时子类是没有完全创建出来，不可能通过父类的指针去调用
   基类的析构函数一定要声明成虚函数
   不然会造成派生类析构不完全，造成内存泄漏。
7. 为什么子类和父类析构函数名不一样，还可以构成重写？
     因为编译器对析构函数的名字做了特殊处理，在内部的函数名一样；


##内存分配
###内存五大区
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27d973bedc234f1d8edcdbbb49907ef0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)
1. 堆区(自由储存区)
    是程序员动态分配和释放的，如果不释放，程序结束后，由操作系统回收，
    需要访问堆内存时，一般先需要通过对象读取到栈区的指针地址，然后通过指针地址访问
   * 储存
    1. c语言中使用malloc分配空间，需要free释放
    2. c++是由new分配空间,delete释放
   * 优点
        1.灵活方便，数据适应广泛
   * 缺点
        1. 需手动管理，速度慢，容易产生内存碎片
2. 栈区
   由编译器自动分配并释放的
   * 储存
      1. 局部变量
      2. 函数参数
   * 优点
      1. 由编译器自动分配并释放，不会产生内存碎片，快速高效
   * 缺点
      1. 内存大小有限制，数据不灵活
3. 全局/静态储存区
   是编译时分配的内存空间，在程序运行过程中，此内存的数据一直存在，程序结束后由系统自动释放，
   * 储存
        1. 未初始化的全局变量和静态变量，即BSS区
        2. 已初始化的全局变量和静态变量，即数据区
   
    全局变量是指变量值可以在运行时被动态修改，而静态变量是static修饰的变量，包含静态局部变量和静态全局变量 
4. 常量区
    常量区是编译时分配的内存空间，在程序结束后由系统释放，
    * 储存
        已经使用了的，且没有指向的字符串常量
    字符串常量因为可能被多次使用，所以在程序运行之前就会提前分配内存；
5. 代码区
   代码区是编译时分配，只要存放程序运行时的代码，代码会被编译成二进制存进内存。

堆栈溢出
一般情况下应用程序是不需要考虑堆和栈大小的，但是事实上堆栈不是无上限的，过多的递归会导致栈溢出，过多的new变量会导致堆溢出
预防堆栈溢出的方法
 1. 避免层次过深的递归
 2. 不要过多的使用局部变量，控制局部变量的大小
 3. 避免分配占用空间太大的对象，并及时释放
 4. 调用系统API修改线程的堆栈大小
###内存对齐
1. 内存对齐的原因
   平台原因：不是所有平台都能够访问任意地址的任意数据————>便于在不同的平台上进行移植
   性能原因：访问未对齐的内存，处理器需要做两次内存访问——————————>提高访问效率
            访问对齐的内存，处理器只需要一次内存访问
2. 内存对齐的原则
   1. 结构体的总大小必须是其内部最大成员的整数倍，不足的要补齐
   2. 结构体的成员要从内部最大元素大小的整数倍地址开始储存
   3. 元素存储的位置一定会从自己宽度的整数倍上开始
3. 一些例子
~~~c++
struct Test
{
    int a;//4   补足至8
    long b;//16  条款3，从9开始
    char c;//18 从17开始
}//总大小是24；//条款1 最大的整数倍
~~~
~~~c++
struct Test
{
    int a;//4
    char b;//8  从5开始，补2字节
    long c;//16
}//总大小是16
~~~

4. 内存对齐的一些问题
   1. 空类的大小？
    C++空类的大小为1(原因：不允许一个对象的大小为0，故用一个字节来区分空类)
    计算大小时注意内存对齐
    继承时，空类的一个字节不会继承到子类中
    组合时：包含空类的话，空类的大小时1，但由于内存对齐的规则往往大于1
   
###一些问题
1. 堆&&栈区别
   |区别|栈|堆|
   |-|-|-|
   |管理方式|编译器自动管理|程序员控制|
   |空间大小|默认栈空间是1M|堆空间是4G|
   |碎片问题|先进先出，不会有内存块从栈中间产生|频繁的new/delete会造成内存空间的不连续，造成大量碎片|
   |分配效率|分配专门的寄存器存放栈的地址，压栈出栈有专门的指令执行，效率高|机制复杂，先搜索一块足够大小的空间，堆的效率比较低|
   |扩展方向|由高向下|从低向上|
2. new/delete&&malloc/free区别
   |区别|new/delete|malloc/free|
   |-|-|-|
   |属性|C++关键字，需要编译器支持|库函数，需要头文件支持|
   |指定内存大小|无需指定内存大小，编译器计算|显式的指出所需内存的大小|
   |返回类型|分配成功后返回对象类型的指针无需类型转换|分配成功后返回void*，在通过强制类型转化成我们需要的类型|
   |分配失败后|抛出异常|返回NULL|
   |是否调用构造/析构函数|new会调用operator new申请内存，然后调用构造函数，初始化成员变量后返回指针类型，delete调用析构函数，再调用operator delete释放内存|库函数，不会调用|
   |重载|C++允许重载new/delete操作符|不允许重载|
   |内存区域|在自由存储区分配空间，自由存储区不等于堆|是在系统维护的堆区动态分配内存|
   |数组的处理|new[]/delete[],delete[]对数组的每个成员调用析构函数|手动设定大小|
   |是否可以相互调用|不能相互调用，必须配对使用|不能相互调用，必须配对使用|
3. 内存泄漏出现的情况
   1. new了一个对象没有及时delete
   2. new[]却没有调用delete[];
   3. 浅拷贝的问题
   4. 没有将基类函数定义为虚函数，导致子类的析构函数没有调用；
4. 如何防止内存泄漏
   1. 内部封装；将内存的分配释放封装到类里，在构造的时候申请内存，在析构的时候释放内存
   2. 使用智能指针
5. 野指针出现的情况
   1. 指针变量没有被初始化
   2. delete掉之后没有置为空，可能会指向一块有用的内存
   3. 指针操作超越了变量的作用范围
6. union和Struct的区别
   1. union和Struct都是由若干个数据类型不同的数据成员组成，使用时，联合体只有一个有效的成员，而结构体所有成员都有效
   2. 对联合体的不同成员赋值，将会覆盖其他成员的值，而对于结构体的不同成员赋值，相互不影响
   3. 联合体的大小是内部所有成员变量的最大值，按照最大值的倍数进行分配，结构体遵循内存对齐原则
##面试题
###类型转换
1. 显式转换
   小括号强制转换 
   > typeA a=typeB(b);
2. 隐式装换
   > float a=0.5
   > int b=a;//b=0;
3. static_cast<tyoe>
   将空指针转换为目标类型的空指针(void* 转换成目标指针)
   实现C++内置类型(enum,int,float,char等)的相互转换
   进行类层次之间的向上类型转换(子类转父类)和向下类型转换(父类转子类，向下不安全，没有进行动态类型检查)
4. const_cast<type>
   把const属性去掉，即将const转换为非const(也可以反过来)，
   只能用于指针或引用
   只能改变对象的底层const(顶层const，本身就是const，底层const，指向对象const)
5. reinterpret_cast<type>
   使用位运算是使用
   将指针转换成整数或将整数转换成指针
6. dynamic_cast<type>
   不能用于内置类型的转换
   转化失败后返回nullptr
   在类层次的上行转换中(子类指针转父类指针)时和static_cast是一样的
   下行转换时(父类指针指向子类)时，会有类型检查的功能，比static_cast更安全

###内联函数与宏
1. 内联函数有什么作用？存不存在什么缺点？
   1. 作用是使编译器在函数调用点上展开函数，可以避免函数调用的开销；
   2. 内联函数的缺点是可能造成代码膨胀，尤其是递归的函数，会造成大量内存开销，exe太大，占用cpu资源，此外内联函数不方便调试，每次修改会重新编译头文件，增加编译时间
2. 内联函数和宏有什么区别？有宏为什么还要内联函数？
   1. define宏命令是在预处理阶段对命令进行替换，inline是在编译阶段在函数调用点处展开函数，节省函数调用的开销
   2. define的话不会对参数的类型进行检查的，因此会出现类型安全的问题，比如传一个定义max命令。但是传递的时候可能传递一个整数和一个字符串，就会出错。但是内联函数在编译阶段进行类型检查
   3. 使用宏的时候可能要添加很多括号，比较容易出错
   
###深拷贝和浅拷贝
1. 浅拷贝
   同一类型的对象之间可以互相赋值，使得两个对象的成员变量的值相同，两个对象仍然是独立的两个对象，这种情况叫浅拷贝
   一般情况下，浅拷贝咩有任何副作用，但是当类中有指针，并且指针指向动态分配的内存空间，析构函数做了动态内存释放的处理，会导致内存问题
   ![](https://s2.51cto.com/images/blog/202107/06/81cb8c01c957e47a18144313b4d0ff42.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=)
2. 深拷贝
   当类中有指针，并且指针有动态内存分配空间，析构函数做了释放处理，往往需要自定义拷贝构造函数，自行给指针动态分配空间，称为深拷贝
   ![](https://s2.51cto.com/images/blog/202107/06/17e5b1aff36a08e7ef85e98d5e9b10d9.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=)
~~~c++
//.h文件
class TestDepthCopy
{
public:
TestDepthCopy::TestDepthCopy()
{
	val = new int(20);
   num=10;
}

TestDepthCopy::TestDepthCopy(TestDepthCopy& a)
{
	this->val = new int(*a.val);//深拷贝
   this->num=a.num;//浅拷贝
}


TestDepthCopy::~TestDepthCopy()
{
	delete val;
}
private:
    int * val;
    int num;
}


int main()
{
    TestDepthCopy a;
    TestDepthCopy b(a);
    delete b;
    delete a;
}

~~~
###动态库&&静态库
1. 静态库(.lib)
   函数和数据被编译成二进制文件
   在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把他们和应用程序的其他模块组合起来编译成最终的可执行文件
   优点：
   1. 发布程序时，不用提供对应的库(库已经被打包到可执行文件里)
   2. 库的加载速度快
   缺点：
   1. 库被打包到应用程序中，导致库的体积很大
   2. 如果库发生了改变，需要重新编译
2. 动态库(.dll)
   在编译链接可执行文件时，只需要引入库，dll中的函数代码和数据并不复制到可执行文件中，在运行时候再加载dll，访问dll中导出的函数。
   优点：
   1. 执行程序体积小
   2. 动态库更新了，不需要重新编译(前提是函数接口没变)
   缺点
   1. 发布程序时，需要将动态库提供给用户
   2. 动态库没有呢打包到应用程序中，加载速度相对较慢
###杂项
1. 指针和引用的区别
   指针：指针保存了对象的内存地址且可以指向不同的对象
   引用：是一个对象的别名，且不存在空引用，声明的时候需要指向对象，且不能再指向其他对象，引用的值改变后，指向对象的值也会改变
   区别：
   1. 指针本质是一个指针，有自己的内存空间，引用只是一个别名
   2. 指针可以指向其他对象，引用初始化指定对象之后就不能指向其他的对象
   3. 指针可以初始化为nullptr，而引用必须被初始化一个已有对象的引用
   4. 指针可以是多级指针，引用只能是一级。
2. 重载，重写，隐藏的区别
   重载：指同一个名字的函数，具有不同的参数列表(参数类型，个数),或不同的返回类型，根据参数列表和返回类型决定调用哪一个函数
   重写：派生类的函数重写了基类中的虚函数，重写的基类的函数必须声明成virtual，并且返回值，参数列表和基类中的函数一致
   隐藏：派生类中的同名函数把基类中的同名函数隐藏了，即基类同名函数内屏蔽掉，此时基类函数不能被声明成virtual；
3. delete和delete[]的区别
   若是基本类型，delete和delete[]效果是一样的，因为系统会自动记录分配的空间，然后释放，对于自定义数据类型就不行了，delete仅仅释放数组第一个元素的内存空间，且仅调用了第一个对象的析构函数，但delete[]会调用数组所有元素的析构函数，并释放所有内存空间。
4. delete[]如何知道要delete多少次(free不用传入具体长度)
   需要在new[]一个对象数组时，需要保存数组的维度，c++的做法是在分配数组空间是多分配四个字节的大小，专门保存数组的大小，这个数组应该就存在这个分配返回的指针周围，在delete[]的时候就可以取出这个保存的数，就知道了需要调用析构函数的次数了
5. 编译阶段原理，从C++源文件到可执行文件的过程？
   包含4个阶段:预处理阶段，编译阶段，汇编阶段，连接阶段
   预处理阶段：预处理阶段处理头文件包含关系，对预处理命令进行替换，生成预编译文件；
   编译阶段：编译预编译文件，生成汇编文件
   汇编阶段：件汇编文件转换成机器码，生成可重定位目标文件(.obj文件)
   连接阶段：将多个目标文件好所需库连接成可执行文件(.exe文件)；
6. #program once 和#ifndef #define #endif异同
   同：保证头文件只被编译一次，因为头文件会在许多文件中多次引用，如果没有指定编译一次，则编译器会重新重定向错误
   异：
   #program once：与编译器有关，有的编译器支持，有的编译器不支持
   #ifndef:c/c++的宏定义，通过宏定义避免这些文件多次编译(在所有支持c++语言的编译器上都有效)；
7. enum 和enum class的区别
   1. 隐式的类型转换
        enum可以隐式的转化成int
        enum class需要强转才能够转换成int
   2. 限定作用域
        enum不限定作用域
        enum class限定作用域
8. struct和class的区别
   1. 默认权限：struct是public,class是private
   2. 继承关系默认权限不同:struct是public，class是private的
   3. class能定义模板函数，struct不能定义模板函数

9. 对象池思想
    对于那些需要频繁创建和销毁的对象，对象池的思想是：首先从对象池中寻找有没有可用的对象，如果没有，就创建对象来使用，然后当一个对象不使用的时候，不是把他删除，而是将它设置为不激活的状态并放入对象池中，等待需要使用的时候再去对象池中寻找，并把他激活。
10. 什么是面向对象？
    对象是具体的某一个事物，这些事物的抽象就是类，类中包含数据(成员变量)和动作(成员函数)
11. 面向对象的三大特性
    * 封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性
    * 继承：子类继承父类的特征和行为，子类有父类的非private方法或成员变量，子类可以对弗雷的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被final关键字修饰时，修饰的类不能继承。修饰的成员不能重写或修改
    * 多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得结论指针呈现不同的表现形式

